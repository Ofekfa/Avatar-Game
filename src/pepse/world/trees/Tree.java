package pepse.world.trees;

import danogl.GameObject;
import danogl.util.Vector2;
import pepse.world.Block;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * Represents a single tree made of a trunk, leaves and fruits.
 *
 * Trees are generated by the {@link Flora} generator. Each tree places a vertical trunk whose
 * bottom aligns with the ground surface, fills a canopy area above the trunk with {@link Leaf}
 * objects and attaches {@link Fruit} objects to leaves.
 */
public class Tree {
    private static final int MIN_TRUNK_BLOCKS = 4;
    private static final int MAX_TRUNK_BLOCKS = 9;
    private static final int CANOPY_HALF_WIDTH_BLOCKS = 2;
    private static final float LEAF_PROBABILITY = 0.85f;
    private static final float FRUIT_PROBABILITY = 0.15f;

    private final GameObject trunk;
    private final List<GameObject> leaves;
    private final List<GameObject> fruits;

    private Tree(GameObject trunk, List<GameObject> leaves, List<GameObject> fruits) {
        this.trunk = trunk;
        this.leaves = leaves;
        this.fruits = fruits;
    }

    /**
     * Factory creating a tree at the given x-coordinate.
     *
     * The trunk bottom is aligned to the ground height returned by {@code groundHeightAt} for
     * {@code trunkX}. Trunk height is randomly chosen between {@link #MIN_TRUNK_BLOCKS}
     * and {@link #MAX_TRUNK_BLOCKS}, a canopy of leaves is created and
     * some leaves may carry fruits.
     *
     * @param trunkX X coordinate where the trunk column is placed.
     * @param groundHeightAt Function mapping x -> ground surface y
     * @param random random instance used for deterministic per-tree randomness.
     * @param onFruitCollected Callback invoked when a fruit is collected, receives the fruit x-position.
     * @return a new {@link Tree} containing trunk, leaves and fruits.
     */
    public static Tree createAt(int trunkX,
                                Function<Float, Float> groundHeightAt,
                                Random random,
                                Consumer<Float> onFruitCollected) {
        float groundY = groundHeightAt.apply((float) trunkX);
        int groundAligned = (int) Math.floor(groundY / Block.SIZE) * Block.SIZE;

        int trunkBlocks = MIN_TRUNK_BLOCKS + random.nextInt(MAX_TRUNK_BLOCKS - MIN_TRUNK_BLOCKS);
        float trunkHeight = trunkBlocks * Block.SIZE;

        Vector2 trunkTopLeft = new Vector2(trunkX, groundAligned - trunkHeight);
        GameObject trunk = new Trunk(trunkTopLeft, trunkHeight);

        float canopyTopY = trunkTopLeft.y() - Block.SIZE;
        float canopyCenterX = trunkX;

        List<GameObject> leaves = new ArrayList<>();
        List<GameObject> fruits = new ArrayList<>();

        for (int dx = -CANOPY_HALF_WIDTH_BLOCKS; dx <= CANOPY_HALF_WIDTH_BLOCKS; dx++) {
            for (int dy = -CANOPY_HALF_WIDTH_BLOCKS; dy <= CANOPY_HALF_WIDTH_BLOCKS; dy++) {
                if (random.nextFloat() > LEAF_PROBABILITY) continue;

                float leafX = canopyCenterX + dx * Block.SIZE;
                float leafY = canopyTopY + dy * Block.SIZE;
                Leaf leaf = new Leaf(new Vector2(leafX, leafY), random);
                leaves.add(leaf);

                if (random.nextFloat() < FRUIT_PROBABILITY) {
                    fruits.add(new Fruit(new Vector2(leafX, leafY), onFruitCollected));
                }
            }
        }
        return new Tree(trunk, leaves, fruits);
    }

    /**
     * @return the trunk GameObject.
     */
    public GameObject trunk() { return trunk; }

    /**
     * @return A list of leaf GameObjects that form tree's canopy
     */
    public List<GameObject> leaves() { return leaves; }

    /**
     * @return A list of fruit GameObjects attached to tree's leaves
     */
    public List<GameObject> fruits() { return fruits; }
}
